import fs from 'fs-extra';
import * as path from 'path';
import * as crypto from 'crypto';
import { prisma } from '@agentworks/db';
import { createLogger } from '@agentworks/shared';
import {
  ProjectFileInfo,
  FileType,
  GitStatus,
  CreateFileOptions,
  UpdateFileOptions,
  ListFilesOptions,
  FileWithContent,
  ProjectInitOptions,
  DIRECTORY_STRUCTURE,
  FILE_TYPE_PATTERNS,
  LANGUAGE_EXTENSIONS,
} from './types.js';

const logger = createLogger('project-files:fs');

const PROJECTS_BASE_PATH = process.env.PROJECTS_BASE_PATH || '/projects';

export class ProjectFileSystem {
  private basePath: string;

  constructor(basePath?: string) {
    this.basePath = basePath || PROJECTS_BASE_PATH;
  }

  getProjectPath(tenantSlug: string, projectSlug: string): string {
    return path.join(this.basePath, tenantSlug, projectSlug);
  }

  async initializeProject(options: ProjectInitOptions): Promise<void> {
    const { tenantSlug, projectSlug, projectName, projectId, primaryLanguage, frameworks } = options;
    const projectPath = this.getProjectPath(tenantSlug, projectSlug);

    logger.info('Initializing project directory', { projectPath, projectId });

    await fs.ensureDir(projectPath);
    await fs.ensureDir(path.join(projectPath, DIRECTORY_STRUCTURE.AGENTWORKS_DIR));
    await fs.ensureDir(path.join(projectPath, DIRECTORY_STRUCTURE.AGENTS_DIR));
    await fs.ensureDir(path.join(projectPath, DIRECTORY_STRUCTURE.DOCS_DIR));
    await fs.ensureDir(path.join(projectPath, DIRECTORY_STRUCTURE.SRC_DIR));
    await fs.ensureDir(path.join(projectPath, DIRECTORY_STRUCTURE.TESTS_DIR));

    const projectMetadata = {
      projectId,
      tenantSlug,
      projectSlug,
      name: projectName,
      primaryLanguage: primaryLanguage || 'typescript',
      frameworks: frameworks || [],
      createdAt: new Date().toISOString(),
      version: 1,
    };

    await fs.writeJson(
      path.join(projectPath, DIRECTORY_STRUCTURE.AGENTWORKS_DIR, 'project.json'),
      projectMetadata,
      { spaces: 2 }
    );

    const gitignore = `# Dependencies
node_modules/
.pnpm-store/

# Build outputs
dist/
build/
.next/
out/

# Environment files
.env
.env.local
.env.*.local

# IDE
.idea/
.vscode/
*.swp
*.swo

# OS files
.DS_Store
Thumbs.db

# Logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# Test coverage
coverage/
.nyc_output/

# AgentWorks internal
.agentworks/cache/
`;

    await fs.writeFile(path.join(projectPath, '.gitignore'), gitignore);

    await fs.writeFile(
      path.join(projectPath, DIRECTORY_STRUCTURE.DOCS_DIR, 'BLUEPRINT.md'),
      `# ${projectName} - Blueprint\n\n*Document auto-generated by AgentWorks*\n\n## Vision\n\n\n## Goals\n\n\n## Success Criteria\n\n`
    );

    await fs.writeFile(
      path.join(projectPath, DIRECTORY_STRUCTURE.DOCS_DIR, 'PRD.md'),
      `# ${projectName} - Product Requirements Document\n\n*Document auto-generated by AgentWorks*\n\n## Overview\n\n\n## Requirements\n\n\n## User Stories\n\n`
    );

    await fs.writeFile(
      path.join(projectPath, DIRECTORY_STRUCTURE.DOCS_DIR, 'MVP.md'),
      `# ${projectName} - MVP Scope\n\n*Document auto-generated by AgentWorks*\n\n## MVP Features\n\n\n## Out of Scope\n\n\n## Success Metrics\n\n`
    );

    await fs.writeFile(
      path.join(projectPath, DIRECTORY_STRUCTURE.DOCS_DIR, 'ARCHITECTURE.md'),
      `# ${projectName} - Architecture\n\n*Document auto-generated by AgentWorks*\n\n## System Overview\n\n\n## Components\n\n\n## Data Flow\n\n`
    );

    await prisma.project.update({
      where: { id: projectId },
      data: {
        slug: projectSlug,
        localPath: projectPath,
      },
    });

    logger.info('Project directory initialized', { projectPath, projectId });
  }

  async createFile(
    projectId: string,
    filePath: string,
    content: string,
    options: CreateFileOptions = {}
  ): Promise<ProjectFileInfo> {
    const project = await this.getProjectDetails(projectId);
    if (!project.localPath) {
      throw new Error(`Project ${projectId} does not have a local path configured`);
    }

    const fullPath = path.join(project.localPath, filePath);
    const dirPath = path.dirname(fullPath);

    await fs.ensureDir(dirPath);
    await fs.writeFile(fullPath, content, 'utf-8');

    const stats = await fs.stat(fullPath);
    const hash = this.computeHash(content);
    const fileType = options.type || this.detectFileType(filePath);
    const language = options.language || this.detectLanguage(filePath);

    const fileRecord = await prisma.projectFile.create({
      data: {
        projectId,
        path: filePath,
        type: fileType,
        language,
        size: stats.size,
        hash,
        lastAgentId: options.agentId || null,
        gitStatus: 'untracked',
        isGenerated: options.isGenerated ?? true,
      },
    });

    logger.info('File created', { projectId, filePath, size: stats.size });

    return this.toProjectFileInfo(fileRecord);
  }

  async readFile(projectId: string, filePath: string): Promise<string> {
    const project = await this.getProjectDetails(projectId);
    if (!project.localPath) {
      throw new Error(`Project ${projectId} does not have a local path configured`);
    }

    const fullPath = path.join(project.localPath, filePath);

    if (!(await fs.pathExists(fullPath))) {
      throw new Error(`File not found: ${filePath}`);
    }

    return fs.readFile(fullPath, 'utf-8');
  }

  async updateFile(
    projectId: string,
    filePath: string,
    content: string,
    options: UpdateFileOptions = {}
  ): Promise<ProjectFileInfo> {
    const project = await this.getProjectDetails(projectId);
    if (!project.localPath) {
      throw new Error(`Project ${projectId} does not have a local path configured`);
    }

    const fullPath = path.join(project.localPath, filePath);

    if (!(await fs.pathExists(fullPath))) {
      return this.createFile(projectId, filePath, content, { agentId: options.agentId });
    }

    await fs.writeFile(fullPath, content, 'utf-8');

    const stats = await fs.stat(fullPath);
    const hash = this.computeHash(content);

    const fileRecord = await prisma.projectFile.update({
      where: {
        projectId_path: {
          projectId,
          path: filePath,
        },
      },
      data: {
        size: stats.size,
        hash,
        lastAgentId: options.agentId || undefined,
        gitStatus: 'modified',
        updatedAt: new Date(),
      },
    });

    logger.info('File updated', { projectId, filePath, size: stats.size });

    return this.toProjectFileInfo(fileRecord);
  }

  async deleteFile(projectId: string, filePath: string): Promise<void> {
    const project = await this.getProjectDetails(projectId);
    if (!project.localPath) {
      throw new Error(`Project ${projectId} does not have a local path configured`);
    }

    const fullPath = path.join(project.localPath, filePath);

    if (await fs.pathExists(fullPath)) {
      await fs.remove(fullPath);
    }

    await prisma.projectFile.delete({
      where: {
        projectId_path: {
          projectId,
          path: filePath,
        },
      },
    });

    logger.info('File deleted', { projectId, filePath });
  }

  async listFiles(projectId: string, options: ListFilesOptions = {}): Promise<ProjectFileInfo[]> {
    const where: Record<string, unknown> = { projectId };

    if (options.type) {
      where.type = options.type;
    }

    if (options.directory) {
      where.path = { startsWith: options.directory };
    }

    const files = await prisma.projectFile.findMany({
      where,
      orderBy: { path: 'asc' },
    });

    return files.map((f) => this.toProjectFileInfo(f));
  }

  async listFilesWithContent(
    projectId: string,
    options: ListFilesOptions = {}
  ): Promise<FileWithContent[]> {
    const files = await this.listFiles(projectId, options);
    const filesWithContent: FileWithContent[] = [];

    for (const file of files) {
      try {
        const content = await this.readFile(projectId, file.path);
        filesWithContent.push({ ...file, content });
      } catch {
        filesWithContent.push({ ...file, content: '' });
      }
    }

    return filesWithContent;
  }

  async fileExists(projectId: string, filePath: string): Promise<boolean> {
    const project = await this.getProjectDetails(projectId);
    if (!project.localPath) {
      return false;
    }

    const fullPath = path.join(project.localPath, filePath);
    return fs.pathExists(fullPath);
  }

  async getFileInfo(projectId: string, filePath: string): Promise<ProjectFileInfo | null> {
    const fileRecord = await prisma.projectFile.findUnique({
      where: {
        projectId_path: {
          projectId,
          path: filePath,
        },
      },
    });

    return fileRecord ? this.toProjectFileInfo(fileRecord) : null;
  }

  async updateGitStatus(projectId: string, filePath: string, status: GitStatus): Promise<void> {
    await prisma.projectFile.update({
      where: {
        projectId_path: {
          projectId,
          path: filePath,
        },
      },
      data: { gitStatus: status },
    });
  }

  async getAgentFiles(projectId: string, agentId: string): Promise<ProjectFileInfo[]> {
    const files = await prisma.projectFile.findMany({
      where: {
        projectId,
        lastAgentId: agentId,
      },
      orderBy: { updatedAt: 'desc' },
    });

    return files.map((f) => this.toProjectFileInfo(f));
  }

  private async getProjectDetails(projectId: string) {
    const project = await prisma.project.findUnique({
      where: { id: projectId },
      include: { workspace: true },
    });

    if (!project) {
      throw new Error(`Project not found: ${projectId}`);
    }

    return project;
  }

  private computeHash(content: string): string {
    return crypto.createHash('sha256').update(content).digest('hex').substring(0, 16);
  }

  private detectFileType(filePath: string): FileType {
    const ext = path.extname(filePath).toLowerCase();
    const basename = path.basename(filePath).toLowerCase();

    if (basename.includes('.test.') || basename.includes('.spec.')) {
      return 'test';
    }

    for (const [type, patterns] of Object.entries(FILE_TYPE_PATTERNS)) {
      for (const pattern of patterns) {
        const patternExt = pattern.replace('*', '');
        if (ext === patternExt || basename === pattern) {
          return type as FileType;
        }
      }
    }

    return 'source';
  }

  private detectLanguage(filePath: string): string | null {
    const ext = path.extname(filePath).toLowerCase().replace('.', '');
    return LANGUAGE_EXTENSIONS[ext] || null;
  }

  private toProjectFileInfo(record: {
    id: string;
    projectId: string;
    path: string;
    type: string;
    language: string | null;
    size: number;
    hash: string | null;
    lastAgentId: string | null;
    gitStatus: string | null;
    isGenerated: boolean;
    createdAt: Date;
    updatedAt: Date;
  }): ProjectFileInfo {
    return {
      id: record.id,
      projectId: record.projectId,
      path: record.path,
      type: record.type as FileType,
      language: record.language,
      size: record.size,
      hash: record.hash,
      lastAgentId: record.lastAgentId,
      gitStatus: record.gitStatus as GitStatus | null,
      isGenerated: record.isGenerated,
      createdAt: record.createdAt,
      updatedAt: record.updatedAt,
    };
  }
}

export const projectFs = new ProjectFileSystem();
